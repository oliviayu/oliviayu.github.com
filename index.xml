<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tingting&#39;s Blog on Tingting&#39;s Blog</title>
    <link>/</link>
    <description>Recent content in Tingting&#39;s Blog on Tingting&#39;s Blog</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 07 Aug 2019 00:00:00 +0000</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title></title>
      <link>/about/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/about/about/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>/post/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/post/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Skills</title>
      <link>/author/skills/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/author/skills/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Experience</title>
      <link>/experience/experience/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/experience/experience/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Recent Posts</title>
      <link>/recent_posts/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/recent_posts/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Projects</title>
      <link>/project/projects/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/project/projects/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Recent &amp; Upcoming Talks</title>
      <link>/talk/talks/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/talk/talks/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Contact</title>
      <link>/author/contact/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/author/contact/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Data manipulation in R</title>
      <link>/post/2019-08-07-data_manipulation/</link>
      <pubDate>Wed, 07 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/2019-08-07-data_manipulation/</guid>
      <description>


&lt;div id=&#34;aggregation&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Aggregation&lt;/h1&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(magrittr)
set.seed(1)
ex_dat &amp;lt;- data.frame(group = rep(1:3, each = 2),
                     y = rnorm(6), x = rnorm(6))
ex_dat&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   group          y          x
## 1     1 -0.6264538  0.4874291
## 2     1  0.1836433  0.7383247
## 3     2 -0.8356286  0.5757814
## 4     2  1.5952808 -0.3053884
## 5     3  0.3295078  1.5117812
## 6     3 -0.8204684  0.3898432&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Summarise selected columns by group&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dplyr::group_by(ex_dat, group) %&amp;gt;%
  dplyr::summarise(total_y = sum(y))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 3 x 2
##   group total_y
##   &amp;lt;int&amp;gt;   &amp;lt;dbl&amp;gt;
## 1     1  -0.443
## 2     2   0.760
## 3     3  -0.491&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Summarise all the columns by group&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dplyr::group_by(ex_dat, group) %&amp;gt;%
  dplyr::summarise_all(sum)  # you can replace sum() by any function&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 3 x 3
##   group      y     x
##   &amp;lt;int&amp;gt;  &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
## 1     1 -0.443 1.23 
## 2     2  0.760 0.270
## 3     3 -0.491 1.90&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;reshape&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Reshape&lt;/h1&gt;
&lt;p&gt;Reshaping data is often needed before ploting.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;long_dat &amp;lt;- reshape2::melt(ex_dat, id.vars = &amp;quot;group&amp;quot;)
long_dat&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    group variable      value
## 1      1        y -0.6264538
## 2      1        y  0.1836433
## 3      2        y -0.8356286
## 4      2        y  1.5952808
## 5      3        y  0.3295078
## 6      3        y -0.8204684
## 7      1        x  0.4874291
## 8      1        x  0.7383247
## 9      2        x  0.5757814
## 10     2        x -0.3053884
## 11     3        x  1.5117812
## 12     3        x  0.3898432&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;reshape2::dcast(long_dat, group ~ variable, mean)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   group          y         x
## 1     1 -0.2214052 0.6128769
## 2     2  0.3798261 0.1351965
## 3     3 -0.2454803 0.9508122&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;complete-a-data-frame&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Complete a data frame&lt;/h1&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;df &amp;lt;- tibble::tibble(
  group = c(1:2, 1),
  item_id = c(1:2, 2),
  item_name = c(&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;b&amp;quot;),
  value1 = 1:3,
  value2 = 4:6
)
df %&amp;gt;% tidyr::complete(group, tidyr::nesting(item_id, item_name))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 4 x 5
##   group item_id item_name value1 value2
##   &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;      &amp;lt;int&amp;gt;  &amp;lt;int&amp;gt;
## 1     1       1 a              1      4
## 2     1       2 b              3      6
## 3     2       1 a             NA     NA
## 4     2       2 b              2      5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;df %&amp;gt;% tidyr::complete(group, item_id, item_name)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 8 x 5
##   group item_id item_name value1 value2
##   &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;      &amp;lt;int&amp;gt;  &amp;lt;int&amp;gt;
## 1     1       1 a              1      4
## 2     1       1 b             NA     NA
## 3     1       2 a             NA     NA
## 4     1       2 b              3      6
## 5     2       1 a             NA     NA
## 6     2       1 b             NA     NA
## 7     2       2 a             NA     NA
## 8     2       2 b              2      5&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;extract-subset-of-data&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Extract subset of data&lt;/h1&gt;
&lt;p&gt;Extract variables&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;df %&amp;gt;% dplyr::select(group)
df %&amp;gt;% dplyr::select(tidyselect::starts_with(&amp;quot;item_&amp;quot;))
df %&amp;gt;% dplyr::select(tidyselect::ends_with(&amp;quot;_name&amp;quot;))
df %&amp;gt;% dplyr::select(tidyselect::num_range(&amp;quot;value&amp;quot;, 1:2))
df %&amp;gt;% dplyr::select(tidyselect::contains(&amp;quot;item&amp;quot;))
df %&amp;gt;% dplyr::select(tidyselect::matches(&amp;quot;value.&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Filter rows&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;df %&amp;gt;% dplyr::filter(group == 1)
df %&amp;gt;% dplyr::distinct(group, .keep_all = TRUE)
df %&amp;gt;% dplyr::slice(2:3)  # select rows by position
df %&amp;gt;% dplyr::top_n(2, value1) # select top 2 entries in value1&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>SQL notes</title>
      <link>/post/sql-notes/</link>
      <pubDate>Sun, 14 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/sql-notes/</guid>
      <description>

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;Structured Query Language (SQL) is a standard computer language for &lt;strong&gt;relational&lt;/strong&gt; database management and data manipulation. It can be used to read, write, and  update data. For data scientists, it is mainly used for data retrieval. There are several relational database management systems, such as Oracle, MySQL, and SQLite. Depending on the system you are using, the SQL syntax may be a little bit different.&lt;/p&gt;

&lt;h1 id=&#34;retrieve-data&#34;&gt;Retrieve data&lt;/h1&gt;

&lt;p&gt;Use SELECT statement to query database, filtered by some conditions (optional). The [ ] is used to state optional clauses. To select all columns, use * after the SELECT keyword.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT &amp;lt;col1&amp;gt;, &amp;lt;col2&amp;gt; 
FROM &amp;lt;tablename&amp;gt;
[WHERE &amp;lt;condition&amp;gt;];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Conditional selections used in the WHERE clause:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;=              Equal
&amp;lt;&amp;gt;             Not equal to
&amp;gt;              Greater than
&amp;lt;              Less than
&amp;gt;=             Greater than or equal
&amp;lt;=             Less than or equal
BETWEEN AND    Within a range
IS NULL        Is a null
LIKE           Pattern matching operator
IN (&amp;lt;val1&amp;gt;, &amp;lt;val2&amp;gt;, ...)           
OR
AND
NOT
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Sometimes IN and OR can accomplish the same thing. But in general, IN executes faster than OR and it allows to use another SELECT for subqueries.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;SQL processes AND before OR. Use ( ) when using AND and OR together to avoid confusion in the order of operations.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Wildcards for pattern matching:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Using % for pattern matching: &amp;lsquo;%a&amp;rsquo;, end with a; &amp;lsquo;a%&amp;rsquo;, start with a; &amp;lsquo;%a%&amp;rsquo;, with a in between; &amp;lsquo;a%z&amp;rsquo;, start with a and end with z; &amp;lsquo;a%@gmail.com&amp;rsquo;, grab gmail addresses start with a.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Using underscore _ for matching a single character:  &amp;lsquo;_day&amp;rsquo;, grab four-letter words that end with &amp;lsquo;day&amp;rsquo;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Wildcards take longer to run than regular operators. Avoid using them if they can be replaced by other operators.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The code below select two columns from a table named nameInfo and only select rows where the lastname ends in &amp;ldquo;son&amp;rdquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT firstname, lastname
FROM nameInfo
WHERE lastname LIKE &#39;%son&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;create-table&#34;&gt;Create table&lt;/h1&gt;

&lt;p&gt;Use CREATE TABLE statement to create a new table, with optional constraints associated with each column respectively. The table and column names must start with a letter and can be followed by letters, numbers, or underscores The maximum length of a name is 30 characters.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE TABLE &amp;lt;tablename&amp;gt;
(&amp;lt;column1&amp;gt; &amp;lt;data type&amp;gt; [constraint],
 &amp;lt;column2&amp;gt; &amp;lt;data type&amp;gt; [constraint]
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Use CREATE TEMPORARY TABLE statement to create a temporary table. It is faster to create a temporary table than a real table. However, temporary tables will be deleted when current session is terminated.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE TEMPORARY TABLE &amp;lt;temp_tablename&amp;gt; AS
(
  SELECT *
  FROM &amp;lt;tablename&amp;gt;
  [WHERE &amp;lt;conditions&amp;gt;]
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Common data types in SQL&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;char(size)			Character string with a fixed length.
Varchar(size)		Character string with a maximum number of length.
date				Date value
number(size)		Number value with a maximum number of integer digits.
number(size, d)		Number value with a maximum number of &amp;quot;size&amp;quot; integer digits and a maximum number of &amp;quot;d&amp;quot; fraction digits.
decimal(n, d)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Common constraints&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;UNIQUE			No two records can have the same value in a particular column.
NOT NULL		A column can&#39;t be left blank.
PRIMARY KEY 	Defines a unique identification of each record (or row) in a table. Cannot contain NULL.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE TABLE nameInfo
(idnumber number(12) UNIQUE,
 firstname Varchar(20),
 lastname Varchar(20),
 age number(3),
 country Varchar(10)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;insert-and-delete-rows&#34;&gt;Insert and delete rows&lt;/h1&gt;

&lt;p&gt;Use INSERT INTO statement to insert rows into a table. All strings should be enclosed in &lt;strong&gt;single&lt;/strong&gt; quotes, for example &amp;lsquo;September&amp;rsquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;INSERT INTO &amp;lt;tablename&amp;gt;
       (col_1, ... , col_n)
VALUES (value_1, ..., value_n);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Use DELETE FROM statement to delete rows from a table.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;DELETE FROM &amp;lt;tablename&amp;gt;
WHERE &amp;lt;col_1&amp;gt; OPERATOR &amp;lt;value_1&amp;gt;
[AND|OR &amp;lt;col_2&amp;gt; OPERATOR &amp;lt;value_2&amp;gt;];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Examples&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;INSERT INTO nameInfo
  (idnumber, firstname, lastname, age, country)
VALUES (1234567, &#39;John&#39;, &#39;Lee&#39;, 45, &#39;Canada&#39;);

DELETE FROM nameInfo
WHERE lastname = &#39;May&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;insert-column&#34;&gt;Insert column&lt;/h1&gt;

&lt;p&gt;Add column to a table in a database:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;AFTER TABLE &amp;lt;tablename&amp;gt;
ADD &amp;lt;columnname&amp;gt; &amp;lt;datatype&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT &amp;lt;col1&amp;gt;, &amp;lt;col2&amp;gt;, &amp;lt;col1&amp;gt; + &amp;lt;col2&amp;gt; AS &amp;lt;col3&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;update-records&#34;&gt;Update records&lt;/h1&gt;

&lt;p&gt;Use UPDATE statement to update records that match a specified criteria.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;UPDATE &amp;lt;tablename&amp;gt;
SET &amp;lt;columnname&amp;gt; = &amp;lt;newvalue&amp;gt; [, &amp;lt;nextcolumn&amp;gt; = &amp;lt;newvalue2&amp;gt;, ... ]
WHERE &amp;lt;columnname&amp;gt; OPERATOR &amp;lt;value&amp;gt; 
[AND|OR &amp;lt;column&amp;gt; OPERATOR &amp;lt;value&amp;gt;];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;UPDATE nameInfo
SET lastname = &#39;Li&#39;, age = 48,
WHERE lastname = &#39;Lee&#39; AND firstname = &#39;John&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;drop-a-table&#34;&gt;Drop a table&lt;/h1&gt;

&lt;p&gt;Use DROP TABLE command to delete a table and all rows in the table. It is different from deleting all the records in the table. The former removes the table definition as well as all of its rows and the latter leaves the table including column and constraint information.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;DROP TABLE &amp;lt;tablename&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;sort-a-table&#34;&gt;Sort a table&lt;/h1&gt;

&lt;p&gt;Use ORDER BY statement to sort a table. It must be the last clause in a select statement.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT &amp;lt;col1&amp;gt;, &amp;lt;col2&amp;gt;
FROM &amp;lt;tablename&amp;gt;
ORDER BY &amp;lt;col1&amp;gt; DESC, &amp;lt;col2&amp;gt; ASC, &amp;lt;col3&amp;gt; ASC;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can sort by a column not retrieved and use DESC or ASC for descending or ascending (default) order.&lt;/p&gt;

&lt;h1 id=&#34;aggregate-functions&#34;&gt;Aggregate functions&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;AVG()
COUNT()
MIN()
MAX()
SUM()

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Rows containing NULL values are ignored by AVG(), MIN(), MAX().&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;COUNT(*)&lt;/code&gt;: count all the rows containing values or NULL;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;COUNT(&amp;lt;colname&amp;gt;)&lt;/code&gt;: count all the rows in a specific column ignoring NULL values;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Use DISTINCT on aggregate functions. For example, &lt;code&gt;COUNT( DISTINCT &amp;lt;colname&amp;gt;)&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Examples&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT AVG(score) AS average_score
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;group-data&#34;&gt;Group data&lt;/h1&gt;

&lt;p&gt;Use GROUP BY clause to group data and use HAVING clause for filtering for groups.
They are used after WHERE clause and hence rows filtered out by WHERE will not be included in GROUP BY clause.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT &amp;lt;col1&amp;gt;, &amp;lt;col2&amp;gt;, [some aggregated calculations]
FROM &amp;lt;tablename&amp;gt;
GROUP BY &amp;lt;col1&amp;gt;, &amp;lt;col2&amp;gt;
[HAVING &amp;lt;condition&amp;gt;]; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Every column in your SELECT statement must be present in a GROUP BY clause, except for aggregated calculations.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT customerID, COUNT(*) AS orders
FROM Orders
GROUP BY customerID
HAVING COUNT(*) &amp;gt;= 2 ; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;using-subqueries&#34;&gt;Using subqueries&lt;/h1&gt;

&lt;p&gt;Subqueries are queries embedded into other queries. Since data is often stored in multiple tables, subqueries are useful when it comes to getting information from multiple tables. Moreover, they are often used for adding additional criteria, such as filtering criteria, from another table into your query. Subquery selects can only retrieve a single column.&lt;/p&gt;

&lt;p&gt;There is no limit to the number of subqueries you can have. But the performance in obtaining the results slows down when the subqueries are deeply nested.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT studentID, firstname, lastname, major
FROM studentList
WHERE studentiID IN (
  SELECT studentID
  FROM gradeList
  WHERE score &amp;gt; 80
);
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;joining-tables&#34;&gt;Joining tables&lt;/h1&gt;

&lt;p&gt;A join allows you to retrieve the data from multiple tables in just one query. The result only exists for the duration of the query execution.&lt;/p&gt;

&lt;h2 id=&#34;cartesian-cross-joins&#34;&gt;Cartesian (cross) joins&lt;/h2&gt;

&lt;p&gt;A Cartesian join allows you to take each record from the first table and match it with all of the records from the second table. If the first table contains &lt;code&gt;x&lt;/code&gt; rows and second table contains &lt;code&gt;y&lt;/code&gt; rows, you will have &lt;code&gt;x*y&lt;/code&gt; rows in the end result. It is computationally taxing and is not matching on anything. So it is not frequently used.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT &amp;lt;col1&amp;gt;, &amp;lt;col2&amp;gt;, &amp;lt;col3&amp;gt;
FROM  &amp;lt;table1&amp;gt;  CROSS JOIN &amp;lt;table2&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;inner-joins&#34;&gt;Inner joins&lt;/h2&gt;

&lt;p&gt;An inner join is used to select records that have matching values in both tables on some keys.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT &amp;lt;col1&amp;gt;, &amp;lt;col2&amp;gt;, &amp;lt;col3&amp;gt;
FROM &amp;lt;table1&amp;gt;  INNER JOIN &amp;lt;table2&amp;gt; 
ON &amp;lt;prequalified key1&amp;gt; = &amp;lt;prequalified key2&amp;gt; ;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT studentID, firstname, lastname, score
FROM studentList INNER JOIN gradeList
ON studentList.studentID = gradeList.studentID;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;aliases-and-self-joins&#34;&gt;Aliases and self joins&lt;/h2&gt;

&lt;p&gt;An alias is helpful because it can help you by just shortening names and simplifying how we are pre-qualifying them. It doesn&amp;rsquo;t rewrite anything of the table permanently and is only stored for the duration of the query.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT studentID, firstname, lastname
FROM studentList AS stud, gradeList AS grade
WHERE stud.studentID = grade.studentID ;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A self join takes the table and treat it like two separate tables. The following example matches customers that are from the same city.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT A.name AS name1, B.name AS name2, A.city
FROM Customers A, Customers B
WHERE A.customerID = B.customberID
AND A.city = B.city
ORDER BY A.city;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;left-right-full-outer-joins&#34;&gt;Left, right, full outer joins&lt;/h2&gt;

&lt;p&gt;The left join returns all the records from the table on the left side and the matched records from the right table. The following example selects all customers and any orders they might have:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT C.name, O.orderID
FROM Customers C
LEFT JOIN Orders O 
ON C.customerID = O.customerID
ORDER BY C.name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The difference between the right and left joins is the order the tables are relating. Right joins can be turned into left joins by reversing the order of the tables.&lt;/p&gt;

&lt;p&gt;The full outer join returns all records when there is a match in either left or right table. The following example selects all customers and all orders.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT C.name, O.orderID
FROM Customers C
FULL OUTER JOIN Orders O 
ON C.customerID = O.customerID
ORDER BY C.name ;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;unions&#34;&gt;Unions&lt;/h2&gt;

&lt;p&gt;The UNION is used to combine the result set of two or more SELECT statements. Each SELECT statement within UNION must have the same number of columns and the columns must be in the same order with similar data types.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT &amp;lt;colnames&amp;gt; FROM &amp;lt;table1&amp;gt;
UNION
SELECT &amp;lt;colnames&amp;gt; FROM &amp;lt;table2&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The following example selects the German cities that have suppliers.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT city, country FROM Customers
WHERE country = &#39;germany&#39;
UNION
SELECT city, country FROM supplier
WHERE country = &#39;germany&#39;
ORDER BY city;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;working-with-text-strings&#34;&gt;Working with text strings&lt;/h1&gt;

&lt;h2 id=&#34;concatenations&#34;&gt;Concatenations&lt;/h2&gt;

&lt;p&gt;Use &lt;code&gt;||&lt;/code&gt; to concatenate strings. SQL server supports &lt;code&gt;+&lt;/code&gt; instead of &lt;code&gt;||&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT CompanyName, ContactName, CompanyName || &#39;(&#39; || ContactName || &#39;)&#39;
FROM customers
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;trimming&#34;&gt;Trimming&lt;/h2&gt;

&lt;p&gt;Use LTRIM, RTRIM, TRIM to trim the leading, trailing, or both space from a string.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT TRIM(&amp;quot;	Hello.	&amp;quot;) AS TrimmedString
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;substring&#34;&gt;Substring&lt;/h2&gt;

&lt;p&gt;Use SUBSTR to return the specified number of characters from a particular position of a given string.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT firstname, SUBSTR (firstname, 2, 4)	# pull 4 characters, starting at the 2nd character 
FROM employees
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;upper-and-lower&#34;&gt;Upper and lower&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT UPPER(firstname) FROM employees;
SELECT LOWER(firstname) FROM employees;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;working-with-date-and-time-strings&#34;&gt;Working with date and time strings&lt;/h1&gt;

&lt;p&gt;SQLite supports 5 date and time functions:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;DATE(timestring, modifier, modifier, ...)

TIME(timestring, modifier, modifier, ...)

DATETIME(timestring, modifier, modifier, ...)

JULIANDAY(timestring, modifier, modifier, ...)

# Extract certain parts of a date or time string.
# format components: %Y %m %d %H %M %S %s
STRFTIME(format, timestring, modifier, modifier, ...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A timestring can be in any of the following formats&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;YYYY-MM-DD
YYYY-MM-DD HH:MM
YYYY-MM-DD HH:MM:SS
YYYY-MM-DD HH:MM:SS.SSS
YYYY-MM-DDTHH:MM
YYYY-MM-DDTHH:MM:SS
YYYY-MM-DDTHH:MM:SS.SSS
HH:MM
HH:MM:SS
HH:MM:SS.SSS
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Examples&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT DATE(&#39;now&#39;)	# compute current date
SELECT STRFTIME(&#39;%Y %m %d&#39;, &#39;now&#39;)

SELECT Birthdate, 
	   STRFTIME(&#39;%Y&#39;, Birthdate) AS Year,
	   STRFTIME(&#39;%m&#39;, Birthdate) AS Month,
	   STRFTIME(&#39;%d&#39;, Birthdate) AS Day,
	   DATE((&#39;now&#39;) - Birthdate) AS Age
FROM employees
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;case-statements&#34;&gt;Case statements&lt;/h1&gt;

&lt;p&gt;A case statement mimics if-else statement found in most programming languages. It can be used in SELECT, INSERT, UPDATE, and DELETE statements.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CASE [input_var_name]
WHEN C1 THEN E1
WHEN C2 THEN E2
...
[ELSE else_result]
END new_var_name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT studentid, firstname, lastname, score, 
	   CASE 
			WHEN score &amp;gt;= 60 THEN &#39;pass&#39;
			WHEN score &amp;lt; 60 THEN &#39;fail&#39;
			ELSE &#39;other&#39;
	   END score_category
FROM exam_result
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;views&#34;&gt;Views&lt;/h1&gt;

&lt;p&gt;A view is essentially a stored query. It will be removed after database connect has ended.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Benefits&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;It can add or remove columns without changing the schema.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It provides a simpler option to creating a new table.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It helps us clean up our queries and simplify the queries when we have to write&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It can be used to encapsulate complex queries or calculations that you are trying to write.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE [TEMP] VIEW [IF NOT EXISTS] view_name AS
SELECT &amp;lt;list of column names&amp;gt;
FROM datatable

# To see the view
SELECT *
FROM view_name

# Remove the view
DROP VIEW view_name
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Scala notes III -- Classes and Objects</title>
      <link>/post/2019-06-25-scala3/</link>
      <pubDate>Tue, 25 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/2019-06-25-scala3/</guid>
      <description>


&lt;div id=&#34;classes-and-objects&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Classes and objects&lt;/h1&gt;
&lt;p&gt;In Scala, a class is a blueprint for objects. Once you define a class, you can create objects from the class blueprint with the keyword new. Through the object you can use all functionalities of the defined class.&lt;/p&gt;
&lt;p&gt;An object is a named instance with members such as fields and methods. It is a class that has exactly one instance. There are three uses of objects.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Contain fields and methods that are independent of any environment;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;object Math {
    def divide(x: Int, y: Int) = x / y
    def square(x: Int) = x*x
}

println(Math.square(3))
println(Math square 3)  // works if there is only one augment&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Create instances of classes with the keyword &lt;code&gt;new&lt;/code&gt;;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;class Circle(radius: Double) {
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

val circle1 = new Circle(5.0)
println(circle1.area)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;An object with the same name as a class is called a &lt;em&gt;companion object&lt;/em&gt;. Conversely, the class is the object’s companion class. A companion class or object can access the private members of its companion. Use a companion object for methods and values which are not specific to instances of the companion class.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Create the entry point to a Scala program by defining a &lt;code&gt;main&lt;/code&gt; method with a specific signature.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;object &amp;lt;object name&amp;gt; {
  def main(args: &amp;lt;arg type&amp;gt;) = {

  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;class User(var name: String, var age: Int);

object Demo {
  def main(args: Array[String]) {
    var user = new User(&amp;quot;Max&amp;quot;, 28);
    println(user.name);
    println(user.age);
    user.name = &amp;quot;Tom&amp;quot;;  // rewritable because name is var
    user.age = 23;
    println(user.name);
    println(user.age);
  }
}

//          Getter?     Setter?
// -------  -------    ---------
// var        yes         yes
// val        yes         no
// default    no          no

// you cannot access name outside the class if it&amp;#39;s private
class User2(private var name: String, var age: Int) {
  def printName{ println(name) }
};

var user2 = new User2(&amp;quot;Max&amp;quot;, 28);
println(user2.name); // returns error

// to access name inside a class
user2.printName&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;class-hierarchies&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Class Hierarchies&lt;/h1&gt;
&lt;div id=&#34;auxiliary-constructor&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Auxiliary constructor&lt;/h2&gt;
&lt;p&gt;An alternative constructor for a class.&lt;/p&gt;
&lt;p&gt;With primary constructors, you must have different signatures for your auxiliary constructors; you must call previously defined constructors in your auxiliary constructors.&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;class User(val name: String, var age: Int) { // primary constructor
  def this() {  // auxiliary constructor
    this(&amp;quot;Tim&amp;quot;, 21);
  }

  def this(name: String) {
    this(name, 32);
  }
}

object Demo{
  def main(args: Array[String]) {
    var user1 = new User(&amp;quot;Max&amp;quot;, 28);
    var user2 = new User();
    var user3 = new User(&amp;quot;Max&amp;quot;);
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;class-inheritance-extending-a-class&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Class inheritance: extending a class&lt;/h2&gt;
&lt;p&gt;Scala doesn’t allow multiple inheritance from more than one class.&lt;/p&gt;
&lt;p&gt;A super class Polygon:&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;package Inheritance

class Polygon {
  def area: Double = 0.0;
}

object Polygon {
  def main(args: Array[String]) {
    var poly = new Polygon;
    printArea(poly);

    var rect = new Rectangle(55.2, 20.0);
    printArea(rect);

    var tri = new Triangle(55.2, 20.0);
    printArea(tri);
  }

  def printArea(p: Polygon) {
    println(p.area);
  }    
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A subclass Rectangle:&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;package Inheritance

class Rectangle(var width: Double, var height: Double) extends Polygon {
  override def area: Double = width * height; 
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A subclass Triangle:&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;package Inheritance

class Triangle(var width: Double, var height: Double) extends Polygon {
  override def area: Double = width * height / 2; 
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;override&lt;/code&gt; redefines an existing, non-abstract definition in a subclass.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;abstract-class&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Abstract class&lt;/h2&gt;
&lt;p&gt;An abstract class can contain members which are missing an implementation. Consequently, it cannot be instantiated with the operator &lt;code&gt;new&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;An abstract class does a few things for the inheriting subclass:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;define methods which can be used by the inheriting subclass;&lt;/li&gt;
&lt;li&gt;define abstract methods which the inheriting subclass must implement, in another word, it makes sure that we must implement methods inside subclasses;&lt;/li&gt;
&lt;li&gt;provide a common interface which allows the subclass to be interchanged with all other subclasses i.e. inheritance.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;package Inheritance

abstract class Polygon {
  def area: Double; // doesn&amp;#39;t provide any body to this method
}

object Polygon {
  def main(args: Array[String]) {
    // var poly = new Polygon;   // cannot be instantiated
    // printArea(poly);

    var rect = new Rectangle(55.2, 20.0);
    printArea(rect);

    var tri = new Triangle(55.2, 20.0);
    printArea(tri);
  }

  def printArea(p: Polygon) {
    println(p.area);
  }    
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;trait&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Trait&lt;/h2&gt;
&lt;p&gt;Scala doesn’t allow multiple inheritance and instead they use interface. A trait is a partially created interface.&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;package Inheritance

trait Shape {
  def shape: String;
}

class Rectangle(var width: Double, var height: Double) extends Polygon with Shape {
  override def area: Double = height * width;
  def shape: String = &amp;quot;rectangle&amp;quot;;  // can remove override when inheriting from a trait
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Scala notes II -- Functions</title>
      <link>/post/2019-05-26-scala2/</link>
      <pubDate>Sun, 26 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/2019-05-26-scala2/</guid>
      <description>


&lt;div id=&#34;function-syntax&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Function Syntax&lt;/h1&gt;
&lt;p&gt;Scala is a functional programming language, which means that functions are first-class citizens and you can pass them around as parameters or values.&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;def add(x: Int, y: Int): Int = {
  return x + y;
}
println(add(21, 19));
// Other variants
def multiply(x: Int, y: Int): Int = x * y  // simplified version
def divide(x: Int, y: Int) = x / y  // can ignore the output type if it&amp;#39;s obvious
def substract(x: Int = 10, y: Int = 2) = x - y  // set default values&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can define the function names as operator, e.g. +, *, /, -&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;def +(x: Int, y: Int) = x + y&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;partially-applied-functions&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Partially applied functions&lt;/h2&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;val sum = (a: Int, b: Int, c: Int) =&amp;gt; a+b+c
val f = sum(10, 20, _:Int)
println(f(100)) // returns 130

import java.util.Date
def log(date: Date, message: String) = {
  println(date + &amp;quot;   &amp;quot; + message);
}
val date = new Date;
val newLog = log(date, _ :String);
newLog(&amp;quot;The message 1.&amp;quot;)
newLog(&amp;quot;The message 2.&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;closures&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Closures&lt;/h2&gt;
&lt;p&gt;A closure is a function which uses one or more variables declared outside this function.&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;var number = 10;

//Example 1
val add = (x:Int) =&amp;gt; x + number;
println(add(20))

number = 100
println(add(20))  // If the value of the variable changes, the result changes too.

//Example 2
val add2 = (x:Int) =&amp;gt; {
  number = x+number;
  number
}
println(add2(20))
println(number)  // numbder is 120 now

//Example 3
val number = 10;  // The result won&amp;#39;t change since number is fixed.&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;blocks-and-lexical-scope&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Blocks and Lexical Scope&lt;/h2&gt;
&lt;p&gt;We can write nested functions in blocks to avoid name-space pollution. A block is delimited by braces { … } and it contains a sequence of definitions or expressions. The definitions inside a block are only visible from within the block. The definitions inside a block shadow definitions of the same names outside the block.&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;val x = 0
def f(y: Int) = y + 1
val result = {
  val x = f(3)  // x = 4, f() is visible inside the block
  x * x         // 16, x shadows the x outside the block
} + x           // + 0
// return 16&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;recursive-functions&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Recursive functions&lt;/h2&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;def factorial(n: Int): Int =
  if (n == 0) 1 else n * factorial(n - 1)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This function has a buildup of intermediate results that we have to keep until we can compute the final value so it is not a tail recursive function.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tail Recursion&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;If a function calls itself as its last action, the function’s stack frame can be reused. This is called tail recursion. In general, if the last action of a function consists of calling a function (which may be the same), one stack frame would be sufficient for both functions. Such calls are called tail-calls.&lt;/p&gt;
&lt;p&gt;One can require that a function is tail-recursive using a &lt;code&gt;@tailrec&lt;/code&gt; annotation. If the annotation is given and the implementation of a function is not tail recursive, an error would be issued.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;@tailrec
def factorial(n: Int): Int = {
  def loop(acc: Int, n: Int): Int = 
    if (n == 0) acc 
    else loop(acc * n, n-1)
  loop(1, n)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The interest of tail recursion is mostly to avoid very deep recursive chains. If your input data are such that deep recursive chains could happen, then it’s a good idea to reformulate your function to be tail recursive, to run in constant stack frame, so as to avoid stack overflow exceptions.&lt;/p&gt;
&lt;p&gt;On the other hand, if your input data are not susceptible to deep recursive chains then write your function the clearest way you can, which often is not tail recursive, and don’t worry about the stack frames that are spent. For example, the tail recursive function of factorial above grows very quickly even after very low number of recursive steps. So it is &lt;strong&gt;not worth making factorial a tail recursive function&lt;/strong&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;higher-order-functions&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Higher-order functions&lt;/h1&gt;
&lt;p&gt;An important concept in functional programming is called &lt;strong&gt;higher-order function&lt;/strong&gt;. It lets you pass functions as arguments and return them as results. For example,&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;def sum(a: Int, b: Int, f: Int =&amp;gt; Int): Int = {
  if(a &amp;gt; b) 0
  else f(a) + sum(a+1, b, f)
}
def sumInts(a: Int, b: Int) = sum(a, b, x =&amp;gt; x);  
def sumCubes(a: Int, b: Int) = sum(a, b, x =&amp;gt; x * x * x)&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The &lt;code&gt;Int =&amp;gt; Int&lt;/code&gt; is a &lt;strong&gt;function type&lt;/strong&gt; that maps &lt;code&gt;Int&lt;/code&gt; to &lt;code&gt;Int&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The &lt;code&gt;x =&amp;gt; x&lt;/code&gt; and &lt;code&gt;x =&amp;gt; x * x * x&lt;/code&gt; are &lt;strong&gt;anonymous functions&lt;/strong&gt; (aka function literals) that do not contain function names. Instead of defining a function &lt;code&gt;cube&lt;/code&gt;, for example&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;def cube(x: Int): Int = x * x * x&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;the anonymous function &lt;code&gt;x =&amp;gt; x * x * x&lt;/code&gt; provides a lightweight function definition and is useful when we want to create an inline function. &lt;br /&gt; More examples of anonymous functions:&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;(x, y) =&amp;gt; _+_   // i.e. (x, y) =&amp;gt; x+y
(x, y) =&amp;gt; _min _   // i.e. (x, y) =&amp;gt; x min y
(x, y) =&amp;gt; _max _   // i.e. (x, y) =&amp;gt; x max y
// Anonymous functions with parameters
var add = (x: Int, y: Int) =&amp;gt; x + y
// Anonymous functions without parameters
var word = () =&amp;gt; {&amp;quot;Hello world.&amp;quot;}&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div id=&#34;currying&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Currying&lt;/h2&gt;
&lt;p&gt;Currying is a special form of higher-order function. It can transform a function that takes multiple parameters into a function that consists of (nested) anonymous functions with each taking one parameter. &lt;!--That is, transform `def f(arg1)(arg2)...(argn) = E` to `def f = (arg1 =&gt; (arg2 =&gt; ...(agrn =&gt; E))`.
**Multiple parameter lists**
A simple example would be 
```scala
def add(x: Int) = (y: Int) =&gt; x + y;
println(add(20)(10));

// You can also apply partial applied function in currying
val sum40 = add(40);
println(sum40(100));

//Simpler version in scala
def add2 (x: Int) (y: Int) = x + y;
val sum50 = add2(50)_;  //have to add _
println(sum50(10))
```
--&gt;&lt;/p&gt;
&lt;p&gt;For example, we can rewrite the &lt;code&gt;sum&lt;/code&gt; function which takes three parameters &lt;em&gt;(a, b, f)&lt;/em&gt; to a function that returns a function&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;def sum(f: Int =&amp;gt; Int): (Int, Int) =&amp;gt; Int = {
  def sumF(a: Int, b: Int): Int =
    if(a &amp;gt; b) 0
    else f(a) + sumF(a+1, b)
  sumF
}
def sumInts = sum(x =&amp;gt; x);
def sumCubes = sum(x =&amp;gt; x * x * x) 
println( sumCubes(1, 3) )&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here the &lt;code&gt;sum&lt;/code&gt; function takes one argument &lt;em&gt;f&lt;/em&gt; and returns a function &lt;code&gt;sumF&lt;/code&gt; of type &lt;code&gt;(Int, Int) =&amp;gt; Int&lt;/code&gt;. This allows us to get rid of those parameters &lt;em&gt;a&lt;/em&gt; and &lt;em&gt;b&lt;/em&gt; in &lt;code&gt;sumInts&lt;/code&gt; and &lt;code&gt;sumCubes&lt;/code&gt;. We can also avoid defining &lt;code&gt;sumInts&lt;/code&gt; and &lt;code&gt;sumCubes&lt;/code&gt; by applying &lt;code&gt;sum&lt;/code&gt; to a function directly, for example, &lt;code&gt;sum(cube)(1, 3)&lt;/code&gt; is equivalent to &lt;code&gt;sumCubes(1, 3)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In Scala, functions that return functions are so useful that there is a special syntax for them. For example, the &lt;code&gt;sum&lt;/code&gt; function with the nested &lt;code&gt;sumF&lt;/code&gt; function can be simplified as&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;def sum(f: Int =&amp;gt; Int)(a: Int, b: Int): Int = {
  if(a &amp;gt; b) 0
  else f(a) + sum(f)(a+1, b)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The function type of &lt;code&gt;sum&lt;/code&gt; is &lt;code&gt;(Int =&amp;gt; Int) =&amp;gt; (Int, Int) =&amp;gt; Int&lt;/code&gt; or &lt;code&gt;(Int =&amp;gt; Int) =&amp;gt; ( (Int, Int) =&amp;gt; Int )&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Scala notes I</title>
      <link>/post/2019-05-18-scala1/</link>
      <pubDate>Sat, 18 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/2019-05-18-scala1/</guid>
      <description>


&lt;div id=&#34;data-types&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Data types&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;Boolean  true or false 
Byte     8 bit signed value
Short    16 bit signed value
Char     16 bit unsigned Unicode character
Int      32 bit signed value
Long     64 bit signed value
Float    32 bit IEEE 754 single-precision float
Double   64 bit IEEE 754 double-precision float
String   A sequence of characters

Unit     Corresponds to no value
Null     null or empty references
Nothing  subtype of every other type; includes no ...
Any      The supertype of any type; any object is of ..
AnyRef   The supertype of any reference type&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;More on datatype: &lt;a href=&#34;https://www.tutorialspoint.com/scala/scala_data_types.htm&#34; class=&#34;uri&#34;&gt;https://www.tutorialspoint.com/scala/scala_data_types.htm&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;variables&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Variables &lt;a name=&#34;variables&#34;&gt;&lt;/a&gt;&lt;/h1&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;// mutable variable: variable value can be changed
var myVar : String = &amp;quot;Foo&amp;quot; 
// imutable variable: variable value cannot be changed
val myVar : Int = 10
// Note: scala will detect the data types by the initial values.
val x = {val a: Int = 200; val b: Int = 300; a+b}
// this value is not assigned until x is used (you are only using memory in demand)
lazy val x = 500&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;string&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;String &lt;a name=&#34;string&#34;&gt;&lt;/a&gt;&lt;/h1&gt;
&lt;div id=&#34;string-interpolation&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;String interpolation&lt;/h2&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;val name = &amp;quot;mark&amp;quot;
val age = 18
println(name + &amp;quot; is&amp;quot; + age + &amp;quot; year old.&amp;quot;)
println(s&amp;quot;$name is $age years old.&amp;quot;)
println(f&amp;quot;$name%s is $age%d years old.&amp;quot;)  //typesafe: %s specifies string type and %d specifies double type
// mark is 18 years old.

println(raw&amp;quot;Hello \nworld.&amp;quot;)
// Hello \nworld.
println(s&amp;quot;Hello \nworld.&amp;quot;)
// Hello 
// world.&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;methods-for-strings&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Methods for Strings&lt;/h2&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;val str1: String = &amp;quot;Hello world&amp;quot;;
val str2: String = &amp;quot; Max&amp;quot;;

// calculate length
println(str1.length())  // returns 11

// concatenate
println(str1.concat(str2)) // returns &amp;quot;Hellow world Max&amp;quot;
println(str1 + str2)

// formating 
val num1 = 75;
val num2 = 100.25;
val result = printf(&amp;quot;(%d -- %f -- %s)&amp;quot;, num1, num2, str1);
println(result);
println(&amp;quot;(%d -- %f -- %s)&amp;quot;.format(num1, num2, str1));&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;arrays&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Arrays&lt;/h1&gt;
&lt;p&gt;An array is a data structure which can store fixed-sized sequential elements of same data type.&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;val myarray: Array[Int] = new Array[Int](4);

// index starts from 0 in Scala
myarray(0) = 20; 
myarray(1) = 50; 
myarray(2) = 10; 
myarray(3) = 10;

// println(myarray) // won&amp;#39;t work
for(x &amp;lt;- myarray){
  println(x);
}

// Default values of an array
val myarray2 = new Array[Int](5);  // default value is 0
val myarray2 = new Array[String](5);  // default value is null
val myarray2 = new Array[Double](5);  // default value is 0.0
val myarray2 = new Array[Boolean](5);  // default value is false

// concatenate 
import Array._
val myarray3 = Array(1, 2, 3, 5, 8);
println(myarray3.length)

val result = concat(myarray3, myarray3);
for(x &amp;lt;- result){
  println(x)
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;collections&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Collections&lt;/h1&gt;
&lt;div id=&#34;lists&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Lists&lt;/h2&gt;
&lt;p&gt;Lists are immutable and represent the link lists whereas arrays are mutable and flat.&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;val mylist: List[Int] = List(1, 2, 5, 8);
val names: List[String] = List(&amp;quot;Max&amp;quot;, &amp;quot;Tom&amp;quot;, &amp;quot;John&amp;quot;)
println(mylist)
println(names)
println(mylist(0))
//mylist(0) = 5  // cannot change the value of a list

println(0 :: mylist) // prepend 0 but won&amp;#39;t change mylist
println(Nil)  // create a empty list
println(1 :: 5 :: 9 :: Nil) // create a list
println(List.fill(5)(2))  // returns List(2, 2, 2, 2, 2)

println(mylist.head)
println(names.tail) // print everything except for the first element
println(names.isEmpty)
println(mylist.reverse)
println(mylist.max)

// iterate over each element and run the given function
mylist.foreach( println )

var sum: Int = 0;
mylist.foreach( sum += _)
println(sum)   // sum up all the elements&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;sets&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Sets&lt;/h2&gt;
&lt;p&gt;A set is a collection of different elements of CM data types. So a set cannot have duplicated values inside them.&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;val myset: Set[Int] = Set(1, 2, 2, 5)
println(myset)  // returns Set(1, 2, 5)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;By default, set is immutable in Scala. If we need to declare a mutable set, we can use &lt;em&gt;scala.collection.mutable.Set&lt;/em&gt; instead.&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;val myset2 = scala.collection.mutable.Set(1, 3, 5)
println(myset2)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To add a value into the set&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;println(myset + 10)  
println(myset) // myset is not changed because it&amp;#39;s immutable&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Set is not ordered, which means the new element is assigned to a random location and you cannot index an element.&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;println(myset(8))  // check if 8 exists in myset or not&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Other useful functions in set:&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;println(myset.head)
println(myset.tail)
println(myset.isEmpty)

// concatenate two sets
println(myset ++ myset2) 
println(myset.++(myset2))  

// find intersection of two sets
println(myset.&amp;amp;(myset2))
println(myset.intersect(myset2))

// find min &amp;amp; max
println(myset.min)
println(myset.max)

// for loop
myset.foreach(println)
for(x &amp;lt;- myset){ println(x) }&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;maps&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Maps&lt;/h2&gt;
&lt;p&gt;A map is a collection of key-value pairs, for example 801-max, 802-tom, 804-july.&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;val mymap : Map[Int, String] = Map(801 -&amp;gt; &amp;quot;max&amp;quot;, 802 -&amp;gt; &amp;quot;tom&amp;quot;, 804 -&amp;gt; &amp;quot;july&amp;quot;);
println(mymap)
println(mymap(802))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Duplication of keys is not possible in a map.&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;val mymap : Map[Int, String] = Map(801 -&amp;gt; &amp;quot;max&amp;quot;, 802 -&amp;gt; &amp;quot;tom&amp;quot;, 804 -&amp;gt; &amp;quot;july&amp;quot;, 804 -&amp;gt; &amp;quot;jully&amp;quot;);
println(mymap); // it takes the last entry of 804&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;println(mymap.keys)  // returns a set
println(mymap.values)
println(mymap.isEmpty)
println(mymap.contains(801000)) // check if a key (or exception case) is valid/exist in the map

//for loop
mymap.keys.foreach{ key =&amp;gt;
  println(&amp;quot;key &amp;quot; + key);
  println(&amp;quot;value &amp;quot; + mymap(key));
}

//concatenate
val mymap2 : Map[Int, String] = Map( 805 -&amp;gt; &amp;quot;lua&amp;quot;);
println(mymap ++ mymap2);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;tuples&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Tuples&lt;/h2&gt;
&lt;p&gt;A tuple is a class that can contain different kinds of elements, unlike array. A tuple is immutable in scala. You cannot change a tuple once it’s declared. A tuple can contain 22 elements at most.&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;val mytuple = (1, 2, &amp;quot;hello&amp;quot;, true);
println(mytuple);

val mytuple2 = new Tuple3(1, 2, &amp;quot;hello&amp;quot;); // have to indicate the number of elements in a tuple right after the &amp;quot;Tuple&amp;quot; keyword; maximum number is 22.

println(mytuple._3) // returns the third element

val mytuple3 = new Tuple3(1, &amp;quot;hello&amp;quot;, (2,3))
println(mytuple3._3._2); // print 3

//for loop
mytuple.productIterator.foreach{
  i =&amp;gt; println(i) 
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;options&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Options&lt;/h2&gt;
&lt;p&gt;An option is a container which can give you two values (Some or None).&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;val lst = List(1, 2, 3);
val map = Map(1 -&amp;gt; &amp;quot;Tom&amp;quot;, 2 -&amp;gt; &amp;quot;Max&amp;quot;, 3 -&amp;gt; &amp;quot;John&amp;quot;);
println(lst.find(_ &amp;gt; 6));  // return None
println(lst.find(_ &amp;gt; 2));  // return Some(3)
println(map.get(1)); // return Some(Tom)
println(map.get(4)); // return None

// to abstract the values
println(lst.find(_ &amp;gt; 2).get); // return the element value 3
println(map.get(5).get); // get an exception error message

// to avoid exception error message
println(map.get(5).getOrElse(&amp;quot;No name found.&amp;quot;)); 

// to define options
val opt : Option[Int] = None;
println(opt.isEmpty); // returns true

val opt2 : Option[Int] = Some(55); // returns false&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;comment-code&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Comment code&lt;/h1&gt;
&lt;p&gt;Comment one line&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;// println(&amp;quot;Hello&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Comment multiple lines&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;/*  
println(&amp;quot;Hello&amp;quot;)
println(&amp;quot;world&amp;quot;)
*/&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;ifelse-statement&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Ifelse statement&lt;/h1&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;val x = 20
var res = &amp;quot;&amp;quot;

if(x == 20){
  res = &amp;quot;x==20&amp;quot;
} else {
  res = &amp;quot;x!=20&amp;quot;
}
println(res)

val res2 = if(x == 20) &amp;quot;x==20&amp;quot; else &amp;quot;x!=20&amp;quot;
println(res2)

println(if(x == 20) &amp;quot;x==20&amp;quot; else &amp;quot;x!=20&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Use &amp;amp;&amp;amp; for &lt;em&gt;and&lt;/em&gt; and || for &lt;em&gt;or&lt;/em&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;match-expressions&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Match expressions&lt;/h1&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;val age: Int = 18

age match {
  case 18 =&amp;gt; println(&amp;quot;age 18&amp;quot;)
  case 20 =&amp;gt; println(&amp;quot;age 20&amp;quot;)
  case _ =&amp;gt; println(&amp;quot;default&amp;quot;)  // catch default/unmatched case
}

// use as expression
val result = age match {
  case 18 =&amp;gt; &amp;quot;age 18&amp;quot;
  case 20 =&amp;gt; &amp;quot;age 20&amp;quot;
  case _ =&amp;gt; &amp;quot;default&amp;quot;  // catch default/unmatched case
}
println(&amp;quot;result = &amp;quot; + result)

// mutiple expressions
val i =8;
i match {
  case 1|3|5|7|9 =&amp;gt; println(&amp;quot;odd&amp;quot;)
  case 2|4|6|8|10 =&amp;gt; println(&amp;quot;even&amp;quot;)
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;loops&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Loops&lt;/h1&gt;
&lt;div id=&#34;while-loop&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;while loop&lt;/h2&gt;
&lt;p&gt;check the condition before executing&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;var x = 0
while(x &amp;lt; 10){
    println(&amp;quot;x = &amp;quot; + x)
    x += 1  // x = x + 1
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;do-while-loop&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;do-while loop&lt;/h2&gt;
&lt;p&gt;execute at least once regardless of the condition&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;var y = 0
do {
    println(&amp;quot;y = &amp;quot; + y)
    y += 1  
} while (y &amp;lt; 0);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;for-loop&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;for loop&lt;/h2&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;for ( i &amp;lt;- 1 to 5){
  println(&amp;quot;i using to &amp;quot; + i)
}
// identical
for ( i &amp;lt;- 1 until 6){
  println(&amp;quot;i using to &amp;quot; + i)
}


for ( i &amp;lt;- 1 to 5; j &amp;lt;- 1 to 3){
println(&amp;quot;i,j using to &amp;quot; + i + &amp;quot;,&amp;quot; + j)
}


val lst = List(1, 5, 3, 2, 8)
for( i &amp;lt;- lst; if i &amp;lt; 3){
  println(&amp;quot;i using to &amp;quot; + i)
}
// Use for loop as an expression
val result = for { i &amp;lt;- lst; if i &amp;lt; 3 } yield {
  i * i
}
println(&amp;quot;result = &amp;quot; + result) // return a List&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;map-flatten-and-filter&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Map, flatten, and filter&lt;/h1&gt;
&lt;p&gt;Map method&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;val lst = List(1, 2, 3, 5, 7, 9, 10);
val mymap = Map(1 -&amp;gt; &amp;quot;Tom&amp;quot;, 2 -&amp;gt; &amp;quot;Max&amp;quot;, 3 -&amp;gt; &amp;quot;John&amp;quot;);

// double every element in lst
println(lst.map(x =&amp;gt; x*2))
println(lst.map(_ *2))

println(mymap.mapValues(x =&amp;gt; &amp;quot;hi &amp;quot; + x));

// apply toUpper to every element in the string &amp;quot;hello&amp;quot;
println(&amp;quot;hello&amp;quot;.map(_.toUpper))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Flatten method&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;// flatten contents of a list of lists
println(List(List(1, 2, 3), List(3, 4, 5)).flatten)
println(lst.flatMap(x =&amp;gt; List(x, x+1)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Filter method&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;// abstract even numbers
println(lst.filter(x =&amp;gt; x%2 == 0))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;reduce-fold-and-scan-leftright&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Reduce, fold, and scan (left/right)&lt;/h1&gt;
&lt;p&gt;Reduce method&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;val lst = List(1, 2, 3, 4, 6, 7, 8);
val lst2 = List(&amp;quot;A&amp;quot;, &amp;quot;B&amp;quot;, &amp;quot;C&amp;quot;);

println(lst.reduceLeft(_ + _)) // returns sum of all elements
println(lst2.reduceLeft(_ + _)) // returns &amp;quot;ABC&amp;quot; by (AB)C
println(lst2.reduceRight(_ + _)) // returns &amp;quot;ABC&amp;quot; by A(BC)

println(lst.reduceLeft((x, y) =&amp;gt; {println(x + &amp;quot;,&amp;quot;, + y); x+y;}))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Fold method is similar to reduce method but can insert initial argument.&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;println(lst.foldLeft(10)(_ + _)) // return 10 + sum(lst) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Scan method takes initial value and applies it to each element in reduce method. It returns the map of intermediate results.&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;println(lst.scanLeft(10)(_ + _))
println(lst2.scanLeft(&amp;quot;z&amp;quot;)(_ + _))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;lazy-evaluation&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Lazy evaluation&lt;/h1&gt;
&lt;p&gt;Lazy evaluation is an evaluation strategy that delays the evaluation of an expression until it’s needed. Scala supports strict evaluation by default and lazy evaluation if specified.&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;val e = 9; // strict evaluation
lazy val l = 9; // lazy evaluation&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;call-by-value-v.s.-call-by-name&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;call-by-value v.s. call-by-name&lt;/h2&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;# call-by-value, the general case
def method1(n: Int) {
  println(&amp;quot;Method 1&amp;quot;);
  println(n);
}

# call-by-name
def method2(n: =&amp;gt; Int) {    // use =&amp;gt; 
  println(&amp;quot;Method 2&amp;quot;);
  println(n);
}

val add = (a: Int, b: Int) =&amp;gt; {
  println(&amp;quot;Add&amp;quot;);
  a + b
}

method1(add(5, 6))
// Add
// Method 1
// 11
method2(add(5, 6))
// Method 2
// Add
// 11&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;scala-in-intellij-idea&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Scala in IntelliJ IDEA&lt;/h1&gt;
&lt;div id=&#34;sbt-tasks&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;SBT tasks&lt;/h2&gt;
&lt;p&gt;The following tasks can be run in sbt shell:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Scala interpreter: type &lt;code&gt;console&lt;/code&gt; to start and type &lt;Ctrl+D\&gt; to quit&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Type &lt;code&gt;compile&lt;/code&gt; to compile the source code located in the directory src/main/scala&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Type &lt;code&gt;test&lt;/code&gt; to test the unit tests for the project located in src/test/scala&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If your project has an object with a main method (or an object extending the trait App), then you can run the code in sbt easily by typing &lt;code&gt;run&lt;/code&gt;. In case sbt finds multiple main methods, it will ask you which one you’d like to execute.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;unit-test&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Unit test&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;package example

import java.util.NoSuchElementException

import org.scalatest.FunSuite
import org.junit.runner.RunWith
import org.scalatest.junit.JUnitRunner

/**
 * This class implements a ScalaTest test suite for the methods in object
 * `Lists` that need to be implemented as part of this assignment. A test
 * suite is simply a collection of individual tests for some specific
 * component of a program.
 *
 * A test suite is created by defining a class which extends the type
 * `org.scalatest.FunSuite`. When running ScalaTest, it will automatically
 * find this class and execute all of its tests.
 *
 * Adding the `@RunWith` annotation enables the test suite to be executed
 * inside eclipse using the built-in JUnit test runner.
 *
 * You have two options for running this test suite:
 *
 * - Start the sbt console and run the &amp;quot;test&amp;quot; command
 * - Right-click this file in eclipse and chose &amp;quot;Run As&amp;quot; - &amp;quot;JUnit Test&amp;quot;
 */
 @RunWith(classOf[JUnitRunner])
  class ListsSuite extends FunSuite {
 
  // We fist import all members of the `List` object.
  import Lists._

  test(&amp;quot;sum of a few numbers&amp;quot;) {
    assert(sum(List(1,2,0)) === 3)
    assert(sum(List(-2, -1, -5)) === -8)
    assert(sum(List(0, 0, 0)) === 0)
    assert(sum(List()) === 0)
  }

  test(&amp;quot;max of a few numbers&amp;quot;) {
    assert(max(List(3, 7, 2)) === 7)
    assert(max(List(-3, -7, -2)) === -2)
    assert(max(List(2, 2, 2)) === 2)
    assert(max(List(-3, 0, 3, -5)) === 3)
    intercept[NoSuchElementException]{ max(List()) }
  }

}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;useful-links&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Useful links &lt;a name=&#34;links&#34;&gt;&lt;/a&gt;&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/playlist?list=PLS1QulWo1RIagob5D6kMIAvu7DQC5VTh3&#34;&gt;Youtube tutorial&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://www.coursera.org/learn/progfun1/home/welcome&#34;&gt;Coursera: Functional Programming Principles in Scala&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://www.coursera.org/learn/scala-spark-big-data?authMode=login&amp;amp;errorCode=invalidCredential&#34;&gt;Coursera: Big Data Analysis with Scala and Spark&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://www.tutorialspoint.com/scala/scala_variables.htm&#34;&gt;Document tutorial&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://scalafiddle.io/&#34;&gt;ScalaFiddle&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Git commands</title>
      <link>/post/git-commands/</link>
      <pubDate>Tue, 16 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/git-commands/</guid>
      <description>

&lt;h1 id=&#34;configuration&#34;&gt;Configuration&lt;/h1&gt;

&lt;p&gt;Set up global configuration variables if you haven&amp;rsquo;t done so&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git config --global user.name &amp;quot;&amp;lt;name&amp;gt;&amp;quot;
$ git config --global user.email &amp;quot;&amp;lt;email&amp;gt;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Git should automatically do a rebase when you do a pull, which is what you want&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git config branch.autosetuprebase always
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To set up configuration for &lt;code&gt;DiffMerge&lt;/code&gt;,  follow the guide
&lt;a href=&#34;http://coding4streetcred.com/blog/post/configure-diffmerge-for-your-git-difftool&#34; target=&#34;_blank&#34;&gt;http://coding4streetcred.com/blog/post/configure-diffmerge-for-your-git-difftool&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;local-usage-of-git&#34;&gt;Local Usage of Git&lt;/h1&gt;

&lt;h2 id=&#34;staging&#34;&gt;Staging&lt;/h2&gt;

&lt;p&gt;Check if there is any unstaged or untracked files&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git status
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Add files to the staging&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git add &amp;lt;file.name&amp;gt;           // add a specific file
$ git add .                     // add all files from the current folder
$ git add myfolder/             // add all files from the subfolder &#39;myfolder&#39;
$ git add (-A)                  // add all files from entire working tree, even from upper directory
$ git add --no-all myfolder/    // add all but deleted files from myfolder: ``
$ git add -u or --update        // add all but new or untracked files
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Remove files from the staging&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git reset HEAD &amp;lt;file.name&amp;gt;    // remove a specific file
$ git reset                     // remove everything from the staging area
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Reset&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout -- &amp;lt;filename&amp;gt;    // discard the changes in a file
$ git reset --soft HEAD~1       // leave all your changed files &amp;quot;Changes to be committed&amp;quot;, as git status would put it

$ git reset --soft &amp;lt;commit hash&amp;gt;    // move back to staging dir and keep the modification
$ git reset &amp;lt;commit hash&amp;gt;           // move back to working dir and keep the modification
$ git reset --hard &amp;lt;commit hash&amp;gt;    // revert tracked files back before modification
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ git clean -df         // get rid of any untracked dir and files
$ git reflog            // lifesaver if you accidently delete something important
$ git revert &amp;lt;hash&amp;gt;     // ?
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;commit&#34;&gt;Commit&lt;/h2&gt;

&lt;p&gt;Commit changes&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git commit -m &amp;quot;&amp;lt;messages&amp;gt;&amp;quot;                // commit with a message created
$ git commit --amend -m &amp;quot;&amp;lt;new messages&amp;gt;&amp;quot;    // edit the commit message
$ git commit --amend                        // commit changes to the previous commit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Show commit history&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;how-to-write-a-great-git-commit-message&#34;&gt;How to write a great Git commit message&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Separate subject from body with a blank line&lt;/li&gt;
&lt;li&gt;Limit the subject line to 50 characters&lt;/li&gt;
&lt;li&gt;Capitalize the subject line&lt;/li&gt;
&lt;li&gt;Do not end the subject line with a period&lt;/li&gt;
&lt;li&gt;Use the imperative mood in the subject line&lt;/li&gt;
&lt;li&gt;Wrap the body at 72 characters&lt;/li&gt;
&lt;li&gt;Use the body to explain what and why vs. how&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;edit-a-specific-commit&#34;&gt;Edit a specific commit&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ git rebase -i @~3   # Show the last 3 commits in a text editor
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Find the commit you want, change &lt;code&gt;pick&lt;/code&gt; to &lt;code&gt;e&lt;/code&gt; (edit), and save and close the file.
Git will rewind to that commit, allowing you to either:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;use &lt;code&gt;$ git commit --amend&lt;/code&gt; to make changes, or&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;use &lt;code&gt;$ git reset @~&lt;/code&gt; to discard the last commit, but not the changes to the files
    (i.e. take you to the point you were at when you&amp;rsquo;d edited the files, but hadn&amp;rsquo;t committed yet).&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Then run &lt;code&gt;$ git rebase --continue&lt;/code&gt; and Git will replay the subsequent changes on top of your modified commit. You may be asked to fix some merge conflicts.
Note: &lt;code&gt;@&lt;/code&gt; is shorthand for HEAD, and &lt;code&gt;~&lt;/code&gt; is the commit before the specified commit.&lt;/p&gt;

&lt;p&gt;Other approaches: &lt;a href=&#34;https://stackoverflow.com/questions/1186535/how-to-modify-a-specified-commit-in-git&#34; target=&#34;_blank&#34;&gt;https://stackoverflow.com/questions/1186535/how-to-modify-a-specified-commit-in-git&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;squash-several-commits-into-one&#34;&gt;Squash several commits into one&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Step 1&lt;/strong&gt;: Invoke git to start an interactive rebase session:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$ git rebase -i HEAD~[N]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;where N is the number of commits you want to join, starting from the most resent one. For example &lt;code&gt;$ git rebase -i HEAD~3&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;OR if you have too many commits to count, try&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$ git rebase -i [commit-hash]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;where &lt;code&gt;[commit-hash]&lt;/code&gt; is the hash of the commit just before the first one you want to rewrite from. For example, &lt;code&gt;$ git rebase -i 5392bc&lt;/code&gt; to join the top 3 commits in below&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fdascc Fix at 13:00
asfdsd Fix at 12:00
kgfdas Fix at 11:00
5392bc Fix at 10:00
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Step 2&lt;/strong&gt;: Picking and squashing&lt;/p&gt;

&lt;p&gt;At this point your editor of choice will pop up, showing the list of commits you want to merge in a reverse order. For example,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pick kgfdas Fix at 11:00
pick asfdsd Fix at 12:00
pick fdascc Fix at 13:00
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our task here is to mark all the commits as squashable, except the first/older one: it will be used as a starting point. You mark a commit as squashable by changing the work &lt;code&gt;pick&lt;/code&gt; into &lt;code&gt;squash&lt;/code&gt; next to it (or &lt;code&gt;s&lt;/code&gt; for brevity, as stated in the comments). The result would be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pick kgfdas Fix at 11:00
s asfdsd Fix at 12:00
s fdascc Fix at 13:00
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Save the file and close the editor.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 3&lt;/strong&gt;: Create the new commit&lt;/p&gt;

&lt;p&gt;You have just told Git to combine all three commits into the the first commit in the list. It&amp;rsquo;s now time to give it a name: your editor pops up again with a default message, made of the names of all the commits you have squashed.&lt;/p&gt;

&lt;p&gt;You can leave it as it is and the commit message will result in a list of all the intermediate commits, or wipe out the default message and use something more self-explanatory.&lt;/p&gt;

&lt;h2 id=&#34;branch&#34;&gt;Branch&lt;/h2&gt;

&lt;p&gt;You can edit and commit under a branch which wont affect the master branch at all&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git branch                    // check which branch you are currently in (with *)
$ git branch &amp;lt;branch_name&amp;gt;      // create a branch
$ git checkout &amp;lt;branch_name&amp;gt;    // switch to the selected branch

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ git cherry-pick &amp;lt;commit hash&amp;gt;    # bring the commit to the current branch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Merge Branch&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout master
$ git merge &amp;lt;branch_name&amp;gt;
$ git branch --merged       // check if it&#39;s merged successfully
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Delete a branch&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git branch -d &amp;lt;branch_name&amp;gt;                // delete branch locally
$ git push origin --delete &amp;lt;branch_name&amp;gt;     // delete branch remotely
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;stash&#34;&gt;Stash&lt;/h2&gt;

&lt;p&gt;You can save changes in a temporary place so you can work on other things and come back later. Note that stash won&amp;rsquo;t create anything to commit.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git stash save &amp;quot;&amp;lt;message&amp;gt;&amp;quot;     // save changes in stash
$ git stash list                 // check existing stash
$ git stash apply &amp;lt;stash name&amp;gt;   // fetch the changes in the stash
$ git stash pop                  // apply changes in the top stash (the newest) and drop it from the stash list
$ git stash drop &amp;lt;stash name&amp;gt;    // drop the selected stash
$ git stash clear                // remove all the changes made
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;visual-tool&#34;&gt;Visual Tool&lt;/h2&gt;

&lt;p&gt;DiffMerge&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git difftool
$ git mergetool
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Gitk&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gitk
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;others&#34;&gt;Others&lt;/h2&gt;

&lt;p&gt;Check changes made in the code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git diff &amp;lt;old hash&amp;gt; &amp;lt;new hash&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Create an ignore file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ touch .gitignore
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The .gitignore file is a text file that list the files you want to ignore for tracking.&lt;/p&gt;

&lt;h1 id=&#34;remote-usage-of-git&#34;&gt;Remote Usage of Git&lt;/h1&gt;

&lt;p&gt;Clone a project:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone &amp;lt;url&amp;gt; &amp;lt;where to clone&amp;gt;
$ git clone &amp;lt;url&amp;gt; .    // clone to current directory
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;View info about the remote repository:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git remote -v       // list repository info
$ git branch -a       // list all the branches, localy and remotely
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pull from the remote repository&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git pull origin master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Push changes to the remote repository after making local commitments:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git push origin master                // push to Git
$ git push origin HEAD:refs/for/master  // push to Gerrit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Push branch to the remote repository&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git push -u origin &amp;lt;branch_name&amp;gt;    // -u is used so in future you can just simply use $git pull and $git push
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;references&#34;&gt;References&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Git Development workflow&lt;/strong&gt;:
&lt;a href=&#34;https://wcdma-confluence.rnd.ki.sw.ericsson.se/display/TAE/WMR+GIT+Development+workflow&#34; target=&#34;_blank&#34;&gt;https://wcdma-confluence.rnd.ki.sw.ericsson.se/display/TAE/WMR+GIT+Development+workflow&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Git Basic Commands&lt;/strong&gt;:
&lt;a href=&#34;https://wcdma-confluence.rnd.ki.sw.ericsson.se/display/TAE/Git+Basic+Commands&#34; target=&#34;_blank&#34;&gt;https://wcdma-confluence.rnd.ki.sw.ericsson.se/display/TAE/Git+Basic+Commands&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Git Gerrit&lt;/strong&gt;:
&lt;a href=&#34;https://wcdma-confluence.rnd.ki.sw.ericsson.se/display/TAE/Git+Gerrit&#34; target=&#34;_blank&#34;&gt;https://wcdma-confluence.rnd.ki.sw.ericsson.se/display/TAE/Git+Gerrit&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;More&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://git-scm.com/docs&#34; target=&#34;_blank&#34;&gt;https://git-scm.com/docs&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gerrit-review.googlesource.com/Documentation/intro-user.html#gerrit&#34; target=&#34;_blank&#34;&gt;https://gerrit-review.googlesource.com/Documentation/intro-user.html#gerrit&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>sparklyr (Spark in R)</title>
      <link>/post/2019-04-10-sparklyr/</link>
      <pubDate>Wed, 10 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/2019-04-10-sparklyr/</guid>
      <description>


&lt;div id=&#34;introduction&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;The &lt;code&gt;R&lt;/code&gt; programming language, along with &lt;code&gt;RStudio&lt;/code&gt;, has become one of the most popular tools for data analysis as it contains a large amount of open-source packages developed by a community of statisticians. However, &lt;code&gt;R&lt;/code&gt; or &lt;code&gt;RStudio&lt;/code&gt; is not ideal for Big Data analysis as mostly the data would not fit into R memory. On the other hand, Spark has become the leading platform for big-data analytics. It works with the system to distribute data across clusters and process data in parallel. Moreover it provides native bindings for different languages such as Java, Python, Scala, and R.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sparklyr&lt;/code&gt; is an R package that allows us to analyze data in Spark from R. It supports &lt;code&gt;dplyr&lt;/code&gt;, a popular tool for working with data frame like objects both in memory and out of memory, and many machine learning algorithms to run classifiers, regressions, and so on in Spark. It is extensible that you can create R packages that depend on &lt;code&gt;sparklyr&lt;/code&gt; to call the full Spark API, such as H2O’s &lt;code&gt;rsparkling&lt;/code&gt;, an R package that works with H2O’s machine learning algorithm. With &lt;code&gt;sparklyr&lt;/code&gt; and &lt;code&gt;rsparkling&lt;/code&gt;, we have access to all the tools in H2O for analysis with R and Spark.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;connect-to-spark&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Connect to Spark&lt;/h1&gt;
&lt;p&gt;Suppose that &lt;code&gt;sparklyr&lt;/code&gt; has been successfully installed in your &lt;code&gt;R&lt;/code&gt; environment. To get start with Spark using &lt;code&gt;sparklyr&lt;/code&gt; and a local cluster,&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(sparklyr)
spark_install()
sc &amp;lt;- spark_connect(master = &amp;quot;local&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;or if a Spark cluster has been made available to you&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sc &amp;lt;- spark_connect(master = &amp;quot;&amp;lt;cluster-master&amp;gt;&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When I run &lt;code&gt;spark_connect(master = &amp;quot;local&amp;quot;)&lt;/code&gt;, I got the error message&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;Java 9 is currently unsupported in Spark distributions unless you manually install Hadoop 2.8 and manually configure Spark. Please consider uninstalling Java 9 and reinstalling Java 8. To override this failure set &amp;#39;options(sparklyr.java9 = TRUE)&amp;#39;.&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That’s because on my Windows 10 laptop, my JAVA_HOME was set to &lt;code&gt;C:\Java\jdk&lt;/code&gt;, which has Version 11, in the system environment. I change it to&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;JAVA_HOME = &amp;quot;C:\Java\jre1.8.0_151&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that my Java folder was in &lt;code&gt;C:\Program Files (x86)\..&lt;/code&gt; and it created an issue when connecting to Spark. So I moved the folder directly to &lt;code&gt;C:\..&lt;/code&gt; to solve the problem. Howoever, another error triggers when connecting to Spark&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;---- Output Log ----
Error occurred during initialization of VM
Could not reserve enough space for 2097152KB object heap&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It cannot allocate 2GB and this seems a common issue under Windows with a Java version using x86. To solve this, we can either install java x64 or reduce the default memory&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;config &amp;lt;- spark_config()
config[[&amp;quot;sparklyr.shell.driver-memory&amp;quot;]] &amp;lt;- &amp;quot;512m&amp;quot;
sc &amp;lt;- spark_connect(master = &amp;quot;local&amp;quot;, config = config)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally, I get connected to Spark! Now I can run analyses and build models using Spark from R.&lt;/p&gt;
&lt;p&gt;To monitor and analyze execution, we can go to the Spark’s web interface:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;spark_web(sc)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once we are done with analysis, we can disconnect spark,&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;spark_disconnect(sc)&lt;/code&gt;&lt;/pre&gt;
&lt;!--I&#39;m using a local cluster with Spark 2.4.0 and Hadoop 2.7 on Windows 10. However my computer has Java 11 installed and it gives me an error when running
This means I have to either install Hadoop 2.8 or later or rollback Java to version 8. Emmm... 
I chose the first option and installed Hadoop 2.9.1 in my computer, following the well written instructions by Parixit Odedara (https://exitcondition.com/install-hadoop-windows/). To unpack the compressed files of hadoop, I use the `tar` command in git bash 
```
tar xvf hadoop-2.9.1.tar.gz
```
When editing the PATH in the system environment setting, 
```
%JAVA_HOME%
%HADOOP_HOME%
%HADOOP_BIN%
%HADOOP_HOME%\sbin
```
didn&#39;t work out for me, so I just set the complete paths in the PATH
```
C:\Program Files (x86)\Java\jdk
C:\hadoop-2.9.1
C:\hadoop-2.9.1\bin
C:\hadoop-2.9.1\sbin
```
Similarly in the `etc\hadoop\hadoop-env.cmd` file, I set 
```
set JAVA_HOME=&#34;C:\Program Files (x86)\Java\jdk&#34;
```
--&gt;
&lt;!--
To check which versions are available or installed:
```r
spark_available_versions()
spark_installed_versions()
```
--&gt;
&lt;/div&gt;
&lt;div id=&#34;data-analysis&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Data Analysis&lt;/h1&gt;
&lt;div id=&#34;copy-data-to-spark&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Copy data to Spark&lt;/h2&gt;
&lt;p&gt;The data set &lt;code&gt;mtcars&lt;/code&gt; is a dataframe available in &lt;code&gt;R&lt;/code&gt;. Run &lt;code&gt;?mtcars&lt;/code&gt; to see more details. To copy the data set into Apache Spark&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cars &amp;lt;- copy_to(sc, mtcars)
# or
cars &amp;lt;- sdf_copy_to(sc, mtcars)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we can access the data that was copied into Spark from R using the &lt;code&gt;cars&lt;/code&gt; reference.&lt;/p&gt;
&lt;p&gt;To read data from existing data sources in csv format and copy to Spark,&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cars &amp;lt;- spark_read_csv(sc, &amp;quot;cars.csv&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To export data as a csv file,&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;spark_write_csv(cars, &amp;quot;cars.csv&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Other formats like plain text, JSON, JDBC are supported as well.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;exploratory-data-analysis&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Exploratory data analysis&lt;/h2&gt;
&lt;p&gt;When using Spark from R to analyze data, most regular &lt;code&gt;R&lt;/code&gt; functions, such as &lt;code&gt;nrow&lt;/code&gt;, won’t work directly on the Spark reference &lt;code&gt;cars&lt;/code&gt;. Instead, we can either use SQL through the &lt;code&gt;DBI&lt;/code&gt; package or use &lt;code&gt;dplyr&lt;/code&gt; (strongly preferred). Most of the data transformation made available by &lt;code&gt;dplyr&lt;/code&gt; to work with local data frames are also available to use with a Spark connection. This means that a general approach to learning &lt;code&gt;dplyr&lt;/code&gt; can be taken in order to gain more proficiency with data exploration and preparation with Spark. For example, to count how many records are available in &lt;code&gt;cars&lt;/code&gt;,&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dplyr::count(cars)  # = nrow(mtcars)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To select columns, sample rows, and collect data from Spark,&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;df_in_r &amp;lt;- dplyr::select(cars, hp, mpg) %&amp;gt;% 
             dplyr::sample_n(100) %&amp;gt;% 
             dplyr::collect()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then we can apply regular &lt;code&gt;R&lt;/code&gt; functions on the dataframe &lt;code&gt;df_in_r&lt;/code&gt;, for example&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dim(df_in_r)
plot(df_in_r)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If a particular functionality is not available in Spark and no extension has been developed, we can distribute the R code across the Spark cluster. For example,&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cars %&amp;gt;% spark_apply(nrow)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is a powerful tools but comes with additional complexity that we should only use as a last resort option. We should learn how to do proper data analysis and modeling without having to distribute custom R code across our cluster!&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;corrr&lt;/code&gt; package specializes in correlations. It contains friendly functions to prepare and visualize the results.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(corrr)
cars %&amp;gt;%
  correlate(use = &amp;quot;pairwise.complete.obs&amp;quot;, method = &amp;quot;pearson&amp;quot;) %&amp;gt;% 
  shave() %&amp;gt;%
  rplot()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;sparklyr&lt;/code&gt; package also provides some functions for data transformation and exploratory data analysis. Those functions usually have &lt;code&gt;sdf_&lt;/code&gt; as a prefix.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;modeling&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Modeling&lt;/h2&gt;
&lt;p&gt;Spark MLlib is the component of Spark that allows one to write high level code to perform machine learning tasks on distributed data. Sparklyr provides an interface to the ML algorithms that should be familiar to R users. For example, you can run a linear regression as follows:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;model &amp;lt;- ml_linear_regression(cars, mpg ~ hp)
model %&amp;gt;%
  ml_predict(copy_to(sc, data.frame(hp = 250 + 10 * 1:10))) %&amp;gt;%
  transmute(hp = hp, mpg = prediction) %&amp;gt;%
  full_join(select(cars, hp, mpg)) %&amp;gt;%
  collect() %&amp;gt;%
  plot()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To retrieve additional statistics from the model,&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;broom::glance(model)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Spark provides a wide range of algorithms and feature transformers. Those functions usually have &lt;code&gt;ml_&lt;/code&gt; or &lt;code&gt;ft_&lt;/code&gt; as prefix.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;extensions&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Extensions&lt;/h2&gt;
&lt;p&gt;Many extensions to &lt;code&gt;sparklyr&lt;/code&gt; have been made available, such as &lt;code&gt;sparklyr.nested&lt;/code&gt;, &lt;code&gt;rsparkling&lt;/code&gt;, and &lt;code&gt;Mleap&lt;/code&gt;. The &lt;code&gt;sparklyr.nested&lt;/code&gt; package helps you manage values that contain nested information, for example JSON files. The &lt;code&gt;Mleap&lt;/code&gt; enables Spark pipelines in production. The &lt;code&gt;rsparkling&lt;/code&gt; package provides H2O support. For example, you may convert a Spark dataframe to an H2O frame and then use &lt;code&gt;h2o&lt;/code&gt; package to run basic H2O commands in R.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;h2o_df &amp;lt;- rsparkling::as_h2o_frame(sc, cars)
model &amp;lt;- h2o::h2o.glm(x = &amp;quot;gp&amp;quot;, y = &amp;quot;mpg&amp;quot;, h2o_df, alpha = 0, lambda = 0)
summary(model)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can use the &lt;code&gt;invoke&lt;/code&gt; family of functions to generate the objects you want and write extension function that calls functions in Java or Scala. For example,&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;count_lines &amp;lt;- function(sc, &amp;quot;file&amp;quot;) {
  spark_context(sc) %&amp;gt;%
    invoke(&amp;quot;textFile&amp;quot;, file, 1L) %&amp;gt;%
    invoke(&amp;quot;count&amp;quot;)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;count_lines&lt;/code&gt; function calls the &lt;code&gt;textFile().count()&lt;/code&gt; method in Java [2].&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;references&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;References&lt;/h1&gt;
&lt;p&gt;[1] The R in Spark: Learning Apache Spark with R. &lt;a href=&#34;https://therinspark.com/starting.html#starting-spark-web-interface&#34; class=&#34;uri&#34;&gt;https://therinspark.com/starting.html#starting-spark-web-interface&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;[2] Sparklyr from Rstudio. &lt;a href=&#34;https://spark.rstudio.com/extensions/&#34; class=&#34;uri&#34;&gt;https://spark.rstudio.com/extensions/&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>
